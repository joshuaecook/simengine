%% HN timing network model

function timingNetwork()

%%
% <html><hr></html>

%% Introduction
% This model from Hill et al, 2001 (J Comp Neuro) simulates the rhythmic
% pattern generated by the heartbeat interneuron (HN) from the medicinal
% leech.  This network is interesting because different rhythmic
% patterns are generated by isolated cells, two-cell half-center
% oscillators, and the full 6-cell timing network.  This demo also shows
% how multiple models can be combined together to create hierarchical
% models.

%%
% <html><hr></html>

%% Model Description
% There are three files for this demo.  The first,*createHN34.m* is a model
% of a single HN cell; it contains 13 nonlinear state variables modeling
% the action of 7 ionic currents.  The second *createHCO.m* incorporates two
% single cells models with a model synapse contained in the file
% *createSynapse.m*.  The third file, createTimingNetwork.m, creates two
% half-center oscillators connected by coordinating fibers from the 1,2
% HN cells (defined in *createHN12.m*).


%%
% <html><hr></html>

%% Single Cell - *createHN34.m*
% The model, *hn34*, is defined with one output, *Vm*, and five inputs,
% *gh*, *gleak*, *Eleak*, *ISyn*, and *IStim*.  *gh* is the maximal
% conductance of the hyperpolarization-activated inward current *Ih*;
% *gleak* is the leak current conductance and *Eleak* is the leack
% current reversal potential; *ISyn* represents synaptic input current
% (this input will be used in conjunction with our half-center and
% network models) and *IStim* represents an externally applied input
% current.
%
% The voltage equations for the single cell model are as follow:
%
% $V_{\rm{m}}' = \frac{1}{C} \left( I_{\rm{ext}} - I_{\rm{Na}} -
% I_{\rm{P}} - I_{\rm{CaS}} - I_{\rm{CaF}} - I_{\rm{K1}} - I_{\rm{K2}} -
% I_{\rm{KA}} - I_{\rm{h}} - I_{leak} \right)$
%
% <latex>
% \begin{eqnarray*}
% V_{\rm{m}}' &=& \frac{1}{C} \left( I_{\rm{ext}} - I_{\rm{Na}} - I_{\rm{P}} - I_{\rm{CaS}}  - I_{\rm{CaF}} - I_{\rm{K1}} - I_{\rm{K2}}  - I_{\rm{KA}}  - I_{\rm{h}} - I_{leak} \right) \\
% \end{eqnarray*}
% </latex>
%
% There are a total of 13 state variables in the single-cell model, one
% for the membrane potential and 12 for the ionic current gating
% variables.

% Leech heartbeat timing network model (timing network model)
% From Hill et al, 2001, J. Comp. Neuro
% Copyright 2007-2010 Simatra Modeling Technolgies
% Additional Info at (http://calabreselx.biology.emory.edu/INTRO/INDEX.HTML)

function m = createHN34(t)

if nargin == 0
  % Create a temporal iterator if one is not passed into the function
  t = Iterator('t', 'continuous', 'solver', 'ode23');
end

% Instantiate the hn34 model
m = Model('hn34', t);

% Create the inputs
gh = m.input('gh', 4);
gleak = m.input('gleak', 8);
Eleak = m.input('Eleak', -65);
ISyn = m.input('ISyn', 0);
IStim = m.input('IStim', 0);

% Constants
% Membrane Capacitance
Cmem = 0.499; % pF

%Maximal conductances in nS
gNa = 200;
gP = 7.0;
gCaF = 5.0; 
gCaS = 3.2;
gK1 = 100;
gK2 = 80;
gKA = 80;

ENa = 45; % mV
ECa = 135; 
EK = -70;
Eh = -21;

% States
Vm0 = m.input('Vm0', -45);
Vm = m.state('Vm', Vm0, 'iter', t);
hNa = m.state('hNa', 0.99 , 'iter', t);
mP = m.state('mP', 0.32 , 'iter', t);
mCaS = m.state('mCaS', 0.04 , 'iter', t);
hCaS = m.state('hCaS', 0.78 , 'iter', t);
mCaF = m.state('mCaF', 0.02 , 'iter', t);
hCaF = m.state('hCaF', 0.74 , 'iter', t);
mK1 = m.state('mK1', 0.03, 'iter', t);
hK1 = m.state('hK1', 0.81, 'iter', t);
mKA = m.state('mKA', 0.46, 'iter', t);
hKA = m.state('hKA', 0.05, 'iter', t);
mK2 = m.state('mK2', 0.16, 'iter', t);
mh = m.state('mh', 0.08, 'iter', t);

% Equations

% Helper functions
xinf = @(a, b, V)(1/(1 + exp(a * (V + b))));
taux = @(a, b, c, e, V)(c + e / (1 + exp(a * (V + b))));

% Ionic Currents
mNa = xinf(-0.150, 29, Vm);
INa = gNa*mNa^3*hNa*(Vm - ENa);
IP = gP*mP*(Vm - ENa);
ICaF = gCaF*mCaF^2*hCaF*(Vm - ECa);
ICaS = gCaS*mCaS^2*hCaS*(Vm - ECa);
IK1 = gK1*mK1^2*hK1*(Vm - EK);
IK2 = gK2*mK2^2*(Vm - EK);
IKA = gKA*mKA^2*hKA*(Vm - EK);
Ih = gh*mh^2*(Vm - Eh);
Ileak = gleak*(Vm-Eleak);

% Differential Equations
m.diffequ(hNa, (xinf(0.500, 30, Vm) - hNa) / (0.004 + 0.006/(1 + exp(0.5*(Vm + 28))) + 0.01/(cosh(0.3*(Vm + 27)))));
m.diffequ(mP, (xinf(-0.120, 39, Vm) - mP) / taux(0.4, 57, 0.01, 0.2, Vm));
m.diffequ(mCaF, (xinf(-0.6, 46.7, Vm) - mCaF) / (0.011 + 0.024/cosh(0.3*(Vm + 46.7))));
m.diffequ(hCaF, (xinf(0.35, 55.5, Vm) - hCaF) / taux(0.27, 55, 0.06, 0.31, Vm));
m.diffequ(mCaS, (xinf(-0.42, 47.2, Vm) - mCaS) / taux(-0.4, 48.7, 0.005, 0.134, Vm));
m.diffequ(hCaS, (xinf(0.36, 55, Vm) - hCaS) / taux(-0.25, 43, 0.2, 5.25, Vm));
m.diffequ(mK1, (xinf(-0.143, 21, Vm) - mK1) / taux(.150, 16, .001,.011, Vm));
m.diffequ(hK1, (xinf(.111, 28, Vm) - hK1) / taux(-.143, 13, 0.5, 0.2, Vm));
m.diffequ(mK2, (xinf(-0.083, 20, Vm) - mK2) / taux(0.2, 35, 0.057, 0.043, Vm));
m.diffequ(mKA, (xinf(-.13, 44, Vm) - mKA) / taux(0.2, 30, 0.005, 0.011, Vm));
m.diffequ(hKA, (xinf(.16, 63, Vm) - hKA) / taux(-0.3, 55, 0.026, 0.0085, Vm));
m.diffequ(mh, (1/(1 + 2*exp(.180*(Vm + 47)) + exp(0.5*(Vm + 47))) - mh) / taux(-0.1, 73, 0.7, 1.7, Vm));
m.diffequ(Vm, 1/Cmem*(-INa-IP-ICaF-ICaS-IK1-IK2-IKA-Ih-Ileak+IStim-ISyn));

% Output
m.output('Vm');

end


%%
% <html><hr></html>

%% Half-center Oscillator - *createHCO.m*
% The model *createHCO.m*, takes two *hn34* model cells and connects them
% together using a synapse model defined in *createSynapse.m*.  The synapse
% model takes the pre- and post-synaptic membrane potentials as its
% inputs, and produces a synaptic current as its output.  The createSynapse.m file is below.

% Leech heartbeat timing network model (timing network model)
% From Hill et al, 2001, J. Comp. Neuro
% Copyright 2007-2010 Simatra Modeling Technolgies
% Additional Info at (http://calabreselx.biology.emory.edu/INTRO/INDEX.HTML)

function m = createSynapse(t)

if nargin == 0
  % Create a temporal iterator if one is not passed into the function
  t = Iterator('t', 'continuous', 'solver', 'ode23');
end

% Instantiate the hco model
m = Model('synapse', t);

% Create the inputs
Vpre = m.input('Vpre', 0);
Vpost = m.input('Vpost', 0);
gSyn = m.input('gSyn', 60); % nS
tRise = m.input('tRise', 0.002);
tFall = m.input('tFall', 0.011);

% Constant
Vthresh = -20;
ESyn = -62.5;

% States
fSyn = m.state('fSyn', 0, 'iter', t);
MSyn = m.state('MSyn', 0.1, 'iter', t);

% Equations
taux = @(a, b, c, e, V) (c + e / (1 + exp(a * (V + b))));

m.diffequ(fSyn, piecewise((0.999-fSyn)/tRise, Vpre > Vthresh, ...
                          -fSyn/tFall));
m.diffequ(MSyn, (taux(-0.99, 40, 0.1, 0.9, Vpre) - MSyn) / 0.2);

% Outputs
m.output('ISyn', gSyn * fSyn * MSyn * (Vpost - ESyn));

end


%%
% To combine the
% *hn34* models and the *synapse* model together, we first create
% instantiated submodels.  The listing for createHCO.m is below.
%

% Leech heartbeat timing network model (timing network model)
% From Hill et al, 2001, J. Comp. Neuro
% Copyright 2007-2010 Simatra Modeling Technolgies
% Additional Info at (http://calabreselx.biology.emory.edu/INTRO/INDEX.HTML)


function m = createHCO(t)

if nargin == 0
  % Create a temporal iterator if one is not passed into the function
  t = Iterator('t', 'continuous', 'solver', 'ode23');
end

% Instantiate the hco model
m = Model('hco', t);

% Create the inputs
stimR4 = m.input('stimR4', 0);
Eleak = m.input('Eleak', -62.5);
gleak = m.input('gleak', 11);
Vm0 = m.input('Vm0', -45);

% Add HN34 cell submodels
HNL3 = m.submodel(createHN34(t));
HNR3 = m.submodel(createHN34(t));

HNR3.Vm0 = Vm0;

HNL3.Eleak = Eleak;
HNL3.gleak = gleak;

HNR3.Eleak = Eleak;
HNR3.gleak = gleak;

% Add synapse submodels
synapseR3L3 = m.submodel(createSynapse(t));
synapseL3R3 = m.submodel(createSynapse(t));

synapseR3L3.Vpre = HNR3.Vm;
synapseR3L3.Vpost = HNL3.Vm;
synapseR3L3.gSyn = 60;

synapseL3R3.Vpre = HNL3.Vm;
synapseL3R3.Vpost = HNR3.Vm;
synapseL3R3.gSyn = 60;

HNL3.ISyn = synapseR3L3.ISyn;
HNR3.ISyn = synapseL3R3.ISyn;

HNR3.IStim = stimR4;

% Create outputs
m.output('VmL3', HNL3.Vm);
m.output('VmR3', HNR3.Vm);

end


%%
% When we instantiate a submodel, we can override the default values of
% the submodel's inputs.  In this case, the *Eleak* and *gleak* values
% of HNL3 and HNR3 submodels are overridden with the *Eleak* and *gleak*
% values of the *createHCO.m* model.  The *Vpre* and *Vpost* values of the
% synpase submodels are set to be the membrane potentials of the HNR3
% and HNL3 submodels.  Also, the *gSyn* inputs of both synpases is set
% to be 60 nS.
%
% In order to fully instantiate the output of the half-center
% oscillator, the output of the synapse models must be connected back to
% the HN models.

%%
% <html><hr></html>

%% Simulating the half-center in MATLAB
% The MATLAB m-file *simulateHCO.m* demonstrates how the half-center HN
% model can be compiled and executed with the simex interface.  First,
% the model can be compiled and its interface information stored by
% running simex with the model name as its sole paramter:

% Create the hco model
hco = createHCO;

%%
% Next, the model can be executed by calling simex with a simulation
% time parameter after the model name, and the resulting data can be
% plotted using the simplot command:

data1 = simex(hco, 100);
figure,
simplot(data1)
xlabel('Time (s)')
ylabel('V_m (mV)')
title('HCO model with default state (no HCO activity)')

%%
% This simulation, however, does not show half-center activity because
% the two hn34 models are "state-locked"; their output is identical
% because their model equations and initial state are identical.  In
% order to correct this, we need to create a different set of initial
% conditions for the half-center oscillator.  There are two ways to do
% this.  First, we can set the *Iext* parameter of one of the cells to a
% different value, then run the model for enough time for the cells to
% reach a different state.  We can then save the final state vector
% using simex:

% set a stimulus current to R4, simulate and save the final state
parameters.stimR4 = 1;
[ignore, finalState, finalTime] = simex(hco, 100, parameters);

% save the final state of the previous simulation as our new initial state
initialState = finalState;
% run simulation with default parameters and new initial conditions
data2 = simex(hco, 100, '-resume', initialState);

%%
% When we run simex using the '-resume' option, we start the simulation
% with the initial conditions stored in *initialState*.  An alternative
% method to alter the initial state is to include an input parameter that
% is used as an initial state value, as is done in *exploreEleakGleak.m*.
% Regardless as to the approach used, we should now see the two cells of
% the network enter half-center activity.

figure
simplot(data2)
xlabel('Time (s)')
ylabel('V_m (mV)')
title('HCO model with modified initial state (HCO activity)')


%%
% <html><hr></html>

%% Multi-core simulation of single cell and half-center
% The parallel computing capabilities of simEngine can be used to
% investigate the behavior of the model over the *Eleak - gleak*
% parameter space.  The function *sweepEleakGleak.m* allows us to do
% this by specifying a vector of values for *Eleak* and a vector of
% values for *Gleak*.  These vectors are then combined into a cell array
% parameter structure that is passed into simex for parallel
% computation.

function [singleCellData, HCOData] = exploreEleakGleak(EleakValues, gleakValues)

clear parameters;
%sweeps the hn34 single cell and hco models over the Eleak gleak parameter space
parameters.Eleak = num2cell(repmat(EleakValues, 1, length(gleakValues)));
tmp = repmat(gleakValues, length(EleakValues), 1);
parameters.gleak = num2cell(tmp(:)');

data = simex(createHN34, 100, parameters);

activity = zeros(length(gleakValues), length(EleakValues));

for i = 1:length(gleakValues),
    for j = 1:length(EleakValues),
        idx = (i-1)*length(EleakValues)+j;      
        t = data(idx).Vm(:,1);
        Vm = data(idx).Vm(:,2);
        peakIdx = find(Vm(2:end-1) > Vm(3:end) & Vm(2:end-1) > Vm(1:end-2) & Vm(2:end-1) > -20);
        spikeTimes = t(peakIdx + 1);
        spikeTimes = spikeTimes(spikeTimes > 50);
        if isempty(spikeTimes),
          activity(i,j) = 0;  %neuron is silent
        elseif min(diff(spikeTimes)) > 0.95*mean(diff(spikeTimes))
          activity(i,j) = 1;  %neuron is spiking
        else
            activity(i,j) = 2;  %neuron is bursting
        end
    end
end

singleCellData = activity;


parameters.Vm0 = -55; % hyperpolarize second neuron
data = simex(createHCO, 100, parameters);

activity = zeros(length(gleakValues), length(EleakValues));

for i = 1:length(gleakValues),
    for j = 1:length(EleakValues),
        idx = (i-1)*length(EleakValues)+j;      
        t = data(idx).VmL3(:,1);
        VmL = data(idx).VmL3(:,2);
        VmR = data(idx).VmR3(:,2);
        peakIdxL = find(VmL(2:end-1) > VmL(3:end) & VmL(2:end-1) > VmL(1:end-2) & VmL(2:end-1) > -20);
        peakIdxR = find(VmR(2:end-1) > VmR(3:end) & VmR(2:end-1) > VmR(1:end-2) & VmR(2:end-1) > -20);
        spikeTimesL = t(peakIdxL + 1);
        spikeTimesL = spikeTimesL(spikeTimesL > 50);
        spikeTimesR = t(peakIdxR + 1);
        spikeTimesR = spikeTimesR(spikeTimesR > 50);
        if isempty(spikeTimesL) && isempty(spikeTimesR),
          activity(i,j) = 0;  %both neurons are silent
        elseif min(diff(spikeTimesL)) > 0.95*mean(diff(spikeTimesL)) | ...
            min(diff(spikeTimesR)) > 0.95*mean(diff(spikeTimesR)),
          activity(i,j) = 1;  %one neuron is spiking
        else
          activity(i,j) = 2;  %neurons are bursting
        end
    end
end

HCOData = activity;

end

%%
% The output of the *exploreEleakGleak* function allows us to visualize
% the behavior of the single cell and half-center configurations, as
% shown in "simulateHCO.m":

% simulate the model over the Eleak-gleak parameter space
EleakValues = -65:0.5:-55;
gleakValues = 4:.5:12;
[cellData, HCOData] = exploreEleakGleak(EleakValues, gleakValues);

figure

subplot(1,2,1)
surf(EleakValues, gleakValues, cellData);
view(0,90)
title('Burtsing activity region for single cell')
xlabel('gleak (nS)')
ylabel('Eleak (mV)')

subplot(1,2,2)
surf(EleakValues, gleakValues, HCOData);
view(0,90)
title('Burtsing activity region for half-center')
xlabel('gleak (nS)')
ylabel('Eleak (mV)')

%%
% The above figure shows that the region in which bursting activity is
% generated (red region) is much greater for the half-center than it is
% for the single cell.

%%
% <html><hr></html>

%% Timing network
% The *createTimingNetwork.m* model is built in much the same way as the
% half-center oscillator model.  In the case of the timing network
% model, two half-center oscillators (a total of four hn34 models) are
% linked by coordinating fibers described in the createHN12.m model.

% Leech heartbeat timing network model (timing network model)
% From Hill et al, 2001, J. Comp. Neuro
% Copyright 2007-2010 Simatra Modeling Technolgies
% Additional Info at (http://calabreselx.biology.emory.edu/INTRO/INDEX.HTML)

function m = createHN12(t)

if nargin == 0
  % Create a temporal iterator if one is not passed into the function
  t = Iterator('t', 'continuous', 'solver', 'ode23');
end

% Instantiate the hn34 model
m = Model('hn12', t);

% Inputs
gleak = m.input('gleak', 10);
Eleak = m.input('Eleak', -40);
ISyn = m.input('ISyn', 0);
IStim = m.input('IStim', 0);

% Constants
% Membrane Capacitance
Cmem = 0.5; % pF

% Maximal conductances in nS
gNa = 200;
gK1 = 150;
gK2 = 75;

ENa = 45; % mV
EK = -70;


% States
Vm0 = m.input('Vm0', -45);
Vm = m.state('Vm', Vm0, 'iter', t);
hNa = m.state('hNa', 0.99 , 'iter', t);
mK1 = m.state('mK1', 0.03, 'iter', t);
hK1 = m.state('hK1', 0.81, 'iter', t);
mK2 = m.state('mK2', 0.16, 'iter', t);

% Equations
% Helper functions
xinf = @(a, b, V)(1/(1 + exp(a * (V + b))));
taux = @(a, b, c, e, V)(c + e / (1 + exp(a * (V + b))));

% Ionic Currents
mNa = xinf(-0.150, 29, Vm);
INa = gNa*mNa^3*hNa*(Vm - ENa);
IK1 = gK1*mK1^2*hK1*(Vm - EK);
IK2 = gK2*mK2^2*(Vm - EK);
Ileak = gleak*(Vm-Eleak);

% Differential Equations
m.diffequ(hNa, (xinf(0.500, 30, Vm) - hNa) / (0.004 + 0.006/(1 + exp(0.5*(Vm + 28))) + 0.01/(cosh(0.3*(Vm + 27)))));
m.diffequ(mK1, (xinf(-0.143, 21, Vm) - mK1) / taux(.150, 16, .001,.011, Vm));
m.diffequ(hK1, (xinf(.111, 28, Vm) - hK1) / taux(-.143, 13, 0.5, 0.2, Vm));
m.diffequ(mK2, (xinf(-0.083, 20, Vm) - mK2) / taux(0.2, 35, 0.057, 0.043, Vm));
m.diffequ(Vm, 1/Cmem*(-INa-IK1-IK2-Ileak+IStim-ISyn));

% Output
m.output(Vm);

end


%%
% There
% are a total of 12 synapses in timing network model, two for each cell or
% coordinating fiber.

% Leech heartbeat timing network model (timing network model)
% From Hill et al, 2001, J. Comp. Neuro
% Copyright 2007-2010 Simatra Modeling Technolgies
% Additional Info at (http://calabreselx.biology.emory.edu/INTRO/INDEX.HTML)

function m = createTimingNetwork(t)

if nargin == 0
  % Create a temporal iterator if one is not passed into the function
  t = Iterator('t', 'continuous', 'solver', 'ode23');
end

% Instantiate the timing network model
m = Model('timingNetwork', t);

% Create the inputs
stimR4 = m.input('stimR4', 0);

% For this model, we need an input for each of the initial voltage
% values
HNL3_Vm0 = m.input('HNL3_Vm0', -45);
HNR3_Vm0 = m.input('HNR3_Vm0', -45);
HNL4_Vm0 = m.input('HNL4_Vm0', -45);
HNR4_Vm0 = m.input('HNR4_Vm0', -45);
HNL1_Vm0 = m.input('HNL1_Vm0', -45);
HNR1_Vm0 = m.input('HNR1_Vm0', -45);

% Instantiate submodels
HNL3 = m.submodel(createHN34);
HNR3 = m.submodel(createHN34);

HNL4 = m.submodel(createHN34);
HNR4 = m.submodel(createHN34);

HNL1 = m.submodel(createHN12);
HNR1 = m.submodel(createHN12);

synapseR3L3 = m.submodel(createSynapse);
synapseL3R3 = m.submodel(createSynapse);

synapseR4L4 = m.submodel(createSynapse);
synapseL4R4 = m.submodel(createSynapse);

synapseR1R3 = m.submodel(createSynapse);
synapseR3R1 = m.submodel(createSynapse);

synapseR1R4 = m.submodel(createSynapse);
synapseR4R1 = m.submodel(createSynapse);

synapseL1L3 = m.submodel(createSynapse);
synapseL3L1 = m.submodel(createSynapse);

synapseL1L4 = m.submodel(createSynapse);
synapseL4L1 = m.submodel(createSynapse);

% Connect submodels together
% The 'with' keyword allows multiple inputs to be specified to the
% same submodel in a single statement.
HNL3.with('gleak', 11, 'Eleak', -62.5, 'Vm0', HNL3_Vm0);
HNR3.with('gleak', 11, 'Eleak', -62.4, 'Vm0', HNR3_Vm0);

HNL4.with('gleak', 11, 'Eleak', -62.5, 'Vm0', HNL4_Vm0);
HNR4.with('gleak', 11, 'Eleak', -62.4, 'Vm0', HNR4_Vm0);

HNL1.Vm0 = HNL1_Vm0;
HNR1.Vm0 = HNR1_Vm0;


synapseR3L3.with('Vpre', HNR3.Vm, 'Vpost', HNL3.Vm, 'gSyn', 60);
synapseL3R3.with('Vpre', HNL3.Vm, 'Vpost', HNR3.Vm, 'gSyn', 60);

synapseR4L4.with('Vpre', HNR4.Vm, 'Vpost', HNL4.Vm, 'gSyn', 60);
synapseL4R4.with('Vpre', HNL4.Vm, 'Vpost', HNR4.Vm, 'gSyn', 60);

synapseR1R3.with('Vpre', HNR1.Vm, 'Vpost', HNR3.Vm, 'gSyn', 16);
synapseR3R1.with('Vpre', HNR3.Vm, 'Vpost', HNR1.Vm, 'gSyn', 6, ...
                 'tRise', 0.01, 'tFall', 0.055);

synapseR1R4.with('Vpre', HNR1.Vm, 'Vpost', HNR4.Vm, 'gSyn', 16);
synapseR4R1.with('Vpre', HNR4.Vm, 'Vpost', HNR1.Vm, 'gSyn', 6, ...
                 'tRise', 0.01, 'tFall', 0.055);

synapseL1L3.with('Vpre', HNL1.Vm, 'Vpost', HNL3.Vm, 'gSyn', 16);
synapseL3L1.with('Vpre', HNL3.Vm, 'Vpost', HNL1.Vm, 'gSyn', 6, ...
                 'tRise', 0.01, 'tFall', 0.055);

synapseL1L4.with('Vpre', HNL1.Vm, 'Vpost', HNL4.Vm, 'gSyn', 16);
synapseL4L1.with('Vpre', HNL4.Vm, 'Vpost', HNL1.Vm, 'gSyn', 6, ...
                 'tRise', 0.01, 'tFall', 0.055);

HNL3.ISyn = synapseR3L3.ISyn + synapseL1L3.ISyn;
HNR3.ISyn = synapseL3R3.ISyn + synapseR1R3.ISyn;

HNL4.ISyn = synapseR4L4.ISyn + synapseL1L4.ISyn;
HNR4.ISyn = synapseL4R4.ISyn + synapseR1R4.ISyn;

HNL1.ISyn = synapseL4L1.ISyn + synapseL3L1.ISyn;
HNR1.ISyn = synapseR4R1.ISyn + synapseR3R1.ISyn;

HNR4.IStim = stimR4;

% Outputs
m.output('VmL3', HNL3.Vm);
m.output('VmR3', HNR3.Vm);
m.output('VmL4', HNL4.Vm);
m.output('VmR4', HNR4.Vm);
m.output('VmL1', HNL1.Vm);
m.output('VmR1', HNR1.Vm);

end


%%
% The model is instantiated and run in much the
% same way as the half-center model (complete code to simulate and plot
% the activity of the network is contained in *simulateNetwork.m*:

function simulateNetwork()

% build the Timing Network model using DIESEL for Matlab - return a
% model object
net = createTimingNetwork;

% randomize the initial state vectors
clear parameters;
parameters.HNL3_Vm0 = rand*10-55;
parameters.HNR3_Vm0 = rand*10-55;
parameters.HNL4_Vm0 = rand*10-55;
parameters.HNR4_Vm0 = rand*10-55;
parameters.HNL1_Vm0 = rand*10-55;
parameters.HNR1_Vm0 = rand*10-55;

%set up a good initial state vector
[o, initState, ignore] = simex(net, 100, parameters);

figure, simplot(o);

%run the model with default parameters
data = simex(net, 200, '-resume', initState);

t = data.VmL1(:,1)-100;

figure,
subplot(6,1,1)
plot(t, data.VmL1(:,2), 'r')
axis([0 100 -60 5]);

subplot(6,1,2)
plot(t, data.VmL3(:,2), 'k')
axis([0 100 -60 5]);

subplot(6,1,3)
plot(t, data.VmR3(:,2), 'k')
axis([0 100 -60 5]);

subplot(6,1,4)
plot(t, data.VmL4(:,2), 'b')
axis([0 100 -60 5]);

subplot(6,1,5)
plot(t, data.VmR4(:,2), 'b')
axis([0 100 -60 5]);

subplot(6,1,6)
plot(t, data.VmR1(:,2), 'r')
axis([0 100 -60 5]);

end

simulateNetwork;

%%
% <html><hr></html>

%% References
% Hill A, Masino M, Olsen O, and Calabrese RL.  A Model of a Segmental
% Oscillator in the Leech Heartbeat Neuronal Network.  Journal of
% Computational Neuroscience 10, 281-302, 2001

end
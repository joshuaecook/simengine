# This makefile handles compiling high-performance C code generated by
# simEngine into a shared library object which may be embedded in an
# end-user application. It is invoked by SIMEX when compiling models
# in MATLAB or GNU octave.
#
# The product of compilation is a shared library object called
# 'libsimengine.so'. Additionally, a 'grind_simEngine' executable may
# be produced which links to the shared library and can be used to
# exercise or inspect the simulation, e.g. with valgrind or gdb.
#
# This makefile will automatically invoke GNU octave to regenerate the
# C code if the model definition or the simEngine compiler have been
# touched.
#
# Copyright 2009 Simatra Modeling Technologies, L.L.C.
# For more information, please visit http://www.simatratechnologies.com

include $(SIMENGINEDIR)/include/common.make

# The name of the model must be specified when invoking make.
ifeq ($(MODEL),)
$(error A model name must be specified. Invoke make with 'MODEL=mymodel')
endif
DSL_MODEL = $(basename $(notdir $(MODEL)))

# The total number of models to be simulated.
NUM_MODELS ?= 1
# The hardware platform: one of {CPU, OPENMP, GPU}
TARGET ?= CPU
# The storage class for simulation data: one of {float, double}
SIMENGINE_STORAGE ?= double
# If non-empty, instructs the compiler to produce additional debugging
# information.
DEBUG ?=
# If non-empty, instructs the compiler to produce additional profiling
# information.
PROFILE ?=
# If non-empty, compiles the simulation in hardware emulation mode.
# Only meaningful when TARGET=GPU.
EMULATE ?=

INCLUDES := -I$(SIMENGINEDIR)/include
COMMON = -W -Wall -fPIC
CPPFLAGS := -DNUM_MODELS=$(NUM_MODELS) -DTARGET_$(TARGET) -DSIMENGINE_STORAGE_$(SIMENGINE_STORAGE)
CFLAGS = $(COMMON) $(INCLUDES)
CXXFLAGS = $(COMMON) $(INCLUDES)

LDFLAGS = -L$(SIMENGINEDIR)/lib 
VPATH += lib
LDLIBS = -lsolvers -ldl -lm

ifeq ($(SIMENGINE_STORAGE),float)
LDLIBS += -lcvode_float
else
LDLIBS += -lcvode_double
endif

ifeq ($(TARGET),GPU)
PTXASFLAGS = -v
ifeq ($(OSLOWER),darwin)
NVCCFLAGS = -arch=sm_11 --compiler-options "$(COMMON)" --ptxas-options "$(PTXASFLAGS)" $(INCLUDES)
else
NVCCFLAGS = -arch=sm_13 --compiler-options "$(COMMON)" --ptxas-options "$(PTXASFLAGS)" $(INCLUDES)
endif
INCLUDES += $(CUDA_INCLUDES)
LDFLAGS += $(CUDA_LDFLAGS)
LDLIBS += $(CUDA_LDLIBS)

ifneq ($(EMULATE),)
	NVCCFLAGS += -deviceemu
	CXXFLAGS += -D__DEVICE_EMULATION__
	CFLAGS += -D__DEVICE_EMULATION__
endif
endif

ifeq ($(TARGET),OPENMP)
LDLIBS += $(OPENMP_LDLIBS)
CFLAGS += -fopenmp
endif

ifneq ($(DEBUG),)
	COMMON += -g
	CFLAGS += -gdwarf-2
	NVCCFLAGS += -D_DEBUG
else
	COMMON += -O2
	NVCCFLAGS += --compiler-options -fno-strict-aliasing
	CXXFLAGS += -fno-strict-aliasing
	CFLAGS += -fno-strict-aliasing
endif

ifeq ($(ARCH),x86_64)
	NVCCFLAGS += -m 64
	CXXFLAGS += -arch x86_64
	CFLAGS += -arch x86_64
endif

# ---

.PREFIXES:

.PHONY: all clean remake grind real-clean

ifeq ($(OSLOWER),darwin)
LIBSIMENGINE = libsimengine.dylib
else
LIBSIMENGINE = libsimengine.so
endif

all: $(LIBSIMENGINE)

clean:
	$(RM) $(DSL_MODEL)_parallel.o $(LIBSIMENGINE) grind_simEngine

real-clean: clean
	$(RM) $(DSL_MODEL)*.c $(DSL_MODEL)*.m $(DSL_MODEL)*.cu

remake: clean all

grind: clean $(LIBSIMENGINE) grind_simEngine
	$(GRIND) ./grind_simEngine

grind_simEngine: $(SIMENGINEDIR)/share/simEngine/grind_simEngine.cpp
	$(COMPILE.cpp) -o $@.o $<
	$(LINK.cpp) $(LDFLAGS) -o $@ $@.o $(LDLIBS)

libsimengine.dylib: $(DSL_MODEL)_parallel.o
	$(LINK.c) $(LDFLAGS) -dynamiclib -Wl,-install_name,$@ -o $@ $< $(LDLIBS)

libsimengine.so: $(DSL_MODEL)_parallel.o
	@echo "Creating $@"
	$(LINK.c) $(LDFLAGS) -shared -Wl,-soname,$@ -o $@ $< $(LDLIBS)

ifeq (GPU,$(TARGET))
$(DSL_MODEL)_parallel.cu: $(DSL_MODEL)_parallel.c
	$(LN) $< $@

$(DSL_MODEL)_parallel.o: override CXX = $(NVCC)
$(DSL_MODEL)_parallel.o: override CXXFLAGS = $(NVCCFLAGS)
$(DSL_MODEL)_parallel.o: $(DSL_MODEL)_parallel.cu
	$(COMPILE.cpp) -o $@ $<
endif

#$(DSL_MODEL)_parallel.c: $(MODEL) $(SIMENGINEDIR)/bin/simEngine
#	$(OCTAVE) -q --eval "path('bin',path);simex('$<');"